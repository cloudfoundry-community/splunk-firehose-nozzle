name: PCF
on:
  push:
    branches: [ "develop" ]
  pull_request:
    branches: [ "develop" ]

  workflow_dispatch:

env:
  GO_VERSION: '1.23'
  RUBY_VERSION: '3.3'

jobs:
  workflow_approval:
    name: Approve workflow
    runs-on: ubuntu-latest
    environment: workflow-approval
    steps:
      - name: Approve workflow
        run: echo For security reasons, all pull requests need to be approved first before running any automated CI.

  fossa-scan:
    continue-on-error: true
    runs-on: ubuntu-latest
    needs:
      - workflow_approval
    steps:
      - name:  Checkout
        uses: actions/checkout@v3
        with:
          ref: ${{github.event.pull_request.head.sha}}
          repository: ${{github.event.pull_request.head.repo.full_name}}
      - name: run fossa anlyze and create report
        run: |
          curl -H 'Cache-Control: no-cache' https://raw.githubusercontent.com/fossas/fossa-cli/master/install-latest.sh | bash
          fossa analyze  --include-unused-deps --debug
          fossa report attribution --format text > /tmp/THIRDPARTY
        env:
          FOSSA_API_KEY: ${{ secrets.FOSSA_API_KEY }}
      - name: upload THIRDPARTY file
        uses: actions/upload-artifact@v4
        with:
          name: THIRDPARTY
          path: /tmp/THIRDPARTY
      - name: run fossa test
        run: |
          fossa test --debug
        env:
          FOSSA_API_KEY: ${{ secrets.FOSSA_API_KEY }}

  semgrep:
    needs:
      - workflow_approval
    runs-on: ubuntu-latest
    container:
      # A Docker image with Semgrep installed. Do not change this.
      image: semgrep/semgrep
    name: security-sast-semgrep
    if: github.actor != 'dependabot[bot]'
    steps:
      - uses: actions/checkout@v4
      - run: semgrep ci
        env:
          # Connect to Semgrep AppSec Platform through your SEMGREP_APP_TOKEN.
          # Generate a token from Semgrep AppSec Platform > Settings
          # and add it to your GitHub secrets.
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_PUBLISH_TOKEN }}

  create-env:
    needs:
      - workflow_approval
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      API_ENDPOINT: ${{ steps.get-credentials.outputs.API_ENDPOINT }}
      API_UAA_ENDPOINT: ${{ steps.get-credentials.outputs.API_UAA_ENDPOINT }}
      API_PASSWORD: ${{ steps.get-credentials.outputs.API_PASSWORD }}
      API_CLIENT_PASSWORD: ${{ steps.get-credentials.outputs.API_CLIENT_PASSWORD }}
      ENV_ID: ${{ steps.get-credentials.outputs.ENV_ID }}
    steps:
      - name: Install Selfservice
        run: |
          wget https://github.com/cf-platform-eng/selfservice/releases/download/0.2.9/selfservice
          chmod +x selfservice
          ls -latr

      - name: Get authorization token
        id: auth
        run: |
          set -e
          AUTH_TOKEN_VALUE=""
          for i in 1 2 3; do
            if AUTH_OUTPUT=$(./selfservice auth "$API_TOKEN" 2>&1); then
              echo "${AUTH_OUTPUT}" | cut -c 8- >> "$GITHUB_ENV"
              AUTH_TOKEN_VALUE=$(echo "${AUTH_OUTPUT}" | cut -c 8- | cut -d= -f2-)
              echo "::add-mask::${AUTH_TOKEN_VALUE}"
              break
            fi
            echo "Attempt $i/3 failed, retrying in 10s..."
            [ $i -lt 3 ] && sleep 10
          done
          if [ -z "${AUTH_TOKEN_VALUE}" ]; then
            echo "::error::selfservice auth failed after 3 attempts. Check API_TOKEN secret and network connectivity to auth.isv.ci (runners may have firewall restrictions)."
            exit 1
          fi
        env:
          API_TOKEN: ${{ secrets.API_TOKEN }}

      - name: Claim environment and wait
        run: |
          echo ENV_ID="$(./selfservice claimAndWait isv_ci_tas_lite_4_0 | jq -r '.id')" >> "$GITHUB_ENV"

      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Set up Brew
        uses: Homebrew/actions/setup-homebrew@master

      - name: Install hammer and cf
        run: |
          brew tap pivotal/hammer https://github.com/pivotal/hammer
          brew install hammer

          brew tap pivotal-cf/om https://github.com/pivotal-cf/om
          brew install om
          brew install cloudfoundry/tap/cf-cli

      - name: Credentials
        id: get-credentials
        run: |
          set -e
          ./selfservice get $ENV_ID | jq -r '.credentials' > env.json
          # Try multiple paths for sys_domain (credentials structure may vary by TAS/PCF version)
          SYS_DOMAIN=$(jq -r '[.sys_domain, .properties.sys_domain.value, .properties.sys_domain, .cf.sys_domain] | map(select(. != null and . != "")) | first // empty' ./env.json 2>/dev/null)
          if [ -z "${SYS_DOMAIN}" ]; then
            echo "::error::Could not extract sys_domain from credentials. env.json structure:"
            jq 'keys' ./env.json 2>/dev/null || cat ./env.json | head -c 500
            exit 1
          fi
          echo "::add-mask::${SYS_DOMAIN}"
          echo API_ENDPOINT="https://api.${SYS_DOMAIN}" >> "$GITHUB_OUTPUT"
          echo API_UAA_ENDPOINT="https://uaa.${SYS_DOMAIN}" >> "$GITHUB_OUTPUT"
          API_PASSWORD="$(hammer -t ./env.json om credentials -- -p cf -t json -c .uaa.admin_credentials | jq -r '.password')"
          API_PASSWORD_ENCRYPTED="$(echo $API_PASSWORD | openssl aes-256-cbc -a -pbkdf2 -salt -pass pass:$ENCRYPT_KEY)"
          echo API_PASSWORD=$API_PASSWORD_ENCRYPTED >> "$GITHUB_OUTPUT"
          API_CLIENT_PASSWORD="$(hammer -t ./env.json om credentials -- -p cf -t json -c .uaa.admin_client_credentials | jq -r '.password')"
          API_CLIENT_PASSWORD_ENCRYPTED="$(echo $API_CLIENT_PASSWORD | openssl aes-256-cbc -a -pbkdf2 -salt -pass pass:$ENCRYPT_KEY)"
          echo API_CLIENT_PASSWORD=$API_CLIENT_PASSWORD_ENCRYPTED >> "$GITHUB_OUTPUT"
          echo ENV_ID=$ENV_ID >> "$GITHUB_OUTPUT"
        env:
          ENCRYPT_KEY: ${{ secrets.ENCRYPT_KEY }}
          

  build:
    runs-on: ubuntu-latest
    needs:
      - create-env

    steps:
      - name:  Checkout
        uses: actions/checkout@v3
        with:
          ref: ${{github.event.pull_request.head.sha}}
          repository: ${{github.event.pull_request.head.repo.full_name}}
      - uses: actions/setup-go@v3
        with:
          go-version: ${{ env.GO_VERSION }}
      - run: go version

      # Install Dependencies
      - name: check-files
        run: ls -la
      - name: Install Dependencies
        run: |
          go mod vendor

      # Builder
      - name: Builder
        run: make build

      # Run tests
      - name: Run tests
        run: |
          make testall

      - uses: actions/upload-artifact@v4
        with:
          name: splunk-firehose-nozzle
          path: splunk-firehose-nozzle

  deploy_nozzle:
    env:
      API_ENDPOINT: ${{ needs.create-env.outputs.API_ENDPOINT  }}
      API_PASSWORD: ${{ needs.create-env.outputs.API_PASSWORD  }}
      API_CLIENT_PASSWORD: ${{ needs.create-env.outputs.API_CLIENT_PASSWORD  }}
      API_UAA_ENDPOINT: ${{ needs.create-env.outputs.API_UAA_ENDPOINT  }}
      API_USER: ${{ secrets.API_USER  }}
      CLIENT_ID: ${{ secrets.CLIENT_ID  }}
      CLIENT_SECRET: ${{ secrets.CLIENT_SECRET  }}
      SPLUNK_INDEX: ${{ secrets.SPLUNK_INDEX  }}
      SPLUNK_TOKEN: ${{ secrets.SPLUNK_TOKEN  }}
      SPLUNK_HOST: ${{ secrets.SPLUNK_HOST  }}
      SPLUNK_METRIC_INDEX: ${{ secrets.SPLUNK_METRIC_INDEX  }}

    needs:
      - build
      - create-env
    runs-on: ubuntu-latest
    steps:
      - name: Validate API endpoint
        run: |
          if [ -z "$API_ENDPOINT" ] || [ "$API_ENDPOINT" = "https://api." ] || [[ ! "$API_ENDPOINT" =~ ^https://api\.[a-zA-Z0-9.-]+ ]]; then
            echo "::error::Invalid API_ENDPOINT: '$API_ENDPOINT'. Check create-env job - credentials may have failed to extract sys_domain."
            exit 1
          fi

      - name:  Checkout
        uses: actions/checkout@v3
        with:
          ref: ${{github.event.pull_request.head.sha}}
          repository: ${{github.event.pull_request.head.repo.full_name}}

      - uses: actions/setup-go@v3
        with:
          go-version: ${{ env.GO_VERSION }}
      - run: go version

      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ env.RUBY_VERSION }}
      - run: ruby -v

      - uses: actions/download-artifact@v4
        with:
          name: splunk-firehose-nozzle

      # Install dependencies
      - name: Install dependencies
        run: |
          go mod vendor
          chmod +x splunk-firehose-nozzle

      # Deploy nozzle
      - name: Deploy nozzle
        run: |
          .github/update_manifest.sh
          .github/pre-req.sh
          cf push -f scripts/ci_nozzle_manifest.yml -u process --random-route
        env:
          ENCRYPT_KEY: ${{ secrets.ENCRYPT_KEY }}

        # Nozzle Log
      - name: Nozzle Log
        run: |
          cf logs splunk-firehose-nozzle &
          

  tile-builder:
    env:
      API_ENDPOINT: ${{ needs.create-env.outputs.API_ENDPOINT  }}
      API_PASSWORD: ${{ needs.create-env.outputs.API_PASSWORD  }}
      API_CLIENT_PASSWORD: ${{ needs.create-env.outputs.API_CLIENT_PASSWORD  }}
      API_UAA_ENDPOINT: ${{ needs.create-env.outputs.API_UAA_ENDPOINT  }}
      API_USER: ${{ secrets.API_USER  }}
      CLIENT_ID: ${{ secrets.CLIENT_ID  }}
      CLIENT_SECRET: ${{ secrets.CLIENT_SECRET  }}
      SPLUNK_INDEX: ${{ secrets.SPLUNK_INDEX  }}
      SPLUNK_TOKEN: ${{ secrets.SPLUNK_TOKEN  }}
      SPLUNK_HOST: ${{ secrets.SPLUNK_HOST  }}
      SPLUNK_METRIC_INDEX: ${{ secrets.SPLUNK_METRIC_INDEX  }}

    needs:
      - deploy_nozzle
      - create-env
    runs-on: ubuntu-latest

    steps:
      - name:  Checkout
        uses: actions/checkout@v3
        with:
          ref: ${{github.event.pull_request.head.sha}}
          repository: ${{github.event.pull_request.head.repo.full_name}}

      - uses: actions/setup-go@v3
        with:
          go-version: ${{ env.GO_VERSION }}
      - run: go version

      - uses: actions/download-artifact@v4
        with:
          name: splunk-firehose-nozzle

      # Tile builder
      - name: Tile builder
        run: |
          .github/tile-builder.sh

      - name: Get tile name
        run: |
          echo "tile_name=$(ls tile/product | grep ".pivotal")" >> "$GITHUB_ENV"

      - name: Upload tile
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.tile_name }}
          path: tile/product/${{ env.tile_name }}


  # Skip test for now!
  execute_tests:
    needs:
      - tile-builder
      - create-env
    runs-on: ubuntu-latest
    env:
      API_ENDPOINT: ${{ needs.create-env.outputs.API_ENDPOINT  }}
      API_PASSWORD: ${{ needs.create-env.outputs.API_PASSWORD  }}
      API_CLIENT_PASSWORD: ${{ needs.create-env.outputs.API_CLIENT_PASSWORD  }}
      API_UAA_ENDPOINT: ${{ needs.create-env.outputs.API_UAA_ENDPOINT  }}
      API_USER: ${{ secrets.API_USER  }}
      CLIENT_ID: ${{ secrets.CLIENT_ID  }}
      CLIENT_SECRET: ${{ secrets.CLIENT_SECRET  }}
      SPLUNK_INDEX: ${{ secrets.SPLUNK_INDEX  }}
      SPLUNK_METRIC_INDEX: ${{ secrets.SPLUNK_METRIC_INDEX  }}
      SPLUNK_TOKEN: ${{ secrets.SPLUNK_TOKEN  }}
      SPLUNK_URL: ${{ secrets.SPLUNK_URL  }}
      SPLUNK_USER: ${{ secrets.SPLUNK_USER  }}
      SPLUNK_PASSWORD: ${{ secrets.SPLUNK_PASSWORD  }}
      SPLUNK_HOST: ${{ secrets.SPLUNK_HOST  }}

    steps:
      - name:  Checkout
        uses: actions/checkout@v3
        with:
          ref: ${{github.event.pull_request.head.sha}}
          repository: ${{github.event.pull_request.head.repo.full_name}}

      - name: Setup python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - uses: actions/setup-go@v3
        with:
          go-version: ${{ env.GO_VERSION }}
      - run: go version

      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ env.RUBY_VERSION }}
      - run: ruby -v

      - uses: actions/download-artifact@v4
        with:
          name: splunk-firehose-nozzle

      # Install dependencies
      - name: Install dependencies
        run: |
          go mod vendor
          chmod +x splunk-firehose-nozzle

      # Deploy data-gen
      - name: Deploy data-gen
        run: |
          .github/pre-req.sh
          cf push -f scripts/data_gen_manifest.yml -u process -p tools/data_gen --random-route
          sleep 10
          cf apps
        env:
          ENCRYPT_KEY: ${{ secrets.ENCRYPT_KEY }}

      # Nozzle Log
      - name: Nozzle Log
        run: |
          cf logs splunk-firehose-nozzle &

      # Prepare test environment
      - name: Prepare test environment
        run: |
          .github/pre-functional-test.sh

      # Executing tests
      - name: Executing tests
        run: |
          .github/functional-test.sh

      # Teardown
      - name: Teardown
        if: always()
        run: |
          API_PASSWORD_DEC=$(echo "$API_PASSWORD" | openssl aes-256-cbc -d -pbkdf2 -a -pass pass:"$ENCRYPT_KEY")
          cf login --skip-ssl-validation -a "$API_ENDPOINT" -u "$API_USER" -p "$API_PASSWORD_DEC"
          echo "Teardown deployment env"
          cf target -o "splunk-ci-org" -s "splunk-ci-space"
          cf delete splunk-firehose-nozzle -f
          cf delete data_gen -f
          cf delete-org splunk-ci-org -f
        env:
          ENCRYPT_KEY: ${{ secrets.ENCRYPT_KEY }}


  teardown-env:
    runs-on: ubuntu-latest
    needs:
      - create-env
      - execute_tests
    if: always()
    env:
      ENV_ID: ${{ needs.create-env.outputs.ENV_ID  }}
    steps:
      - name: install-selfservice
        run: |
          wget https://github.com/cf-platform-eng/selfservice/releases/download/0.2.9/selfservice
          chmod +x selfservice
          ls -latr

      - name: auth
        run: |
          set -e
          AUTH_OUTPUT=$(./selfservice auth "$API_TOKEN" 2>&1) || { echo "::error::selfservice auth failed"; exit 1; }
          echo "${AUTH_OUTPUT}" | cut -c 8- >> "$GITHUB_ENV"
        env:
          API_TOKEN: ${{ secrets.API_TOKEN }}

      - name: release environment
        run: |
          ./selfservice release $ENV_ID